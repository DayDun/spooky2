module.exports = grammar({
	name: "Spooky",
	
	extras: $ => [" ", "\n", "\r", $.line_comment, $.block_comment],
	
	word: $ => $.identifier,
	
	inline: $ => [
		$._call_signature,
		$.statement,
		$.simple_statement,
		$.expression
	],
	
	rules: {
		program: $ => repeat(choice(
			$.extern,
			$.struct_definition,
			$.declaration_statement,
			$.function_definition
		)),
		
		extern: $ => seq(
			"extern",
			$._call_signature
		),
		
		struct_definition: $ => seq(
			"struct",
			field("name", $.identifier),
			"{",
			repeat($.declaration_statement),
			"}"
		),
		
		function_definition: $ => seq(
			"func",
			$._call_signature,
			field("body", $.block_statement)
		),
		
		statement: $ => choice(
			$.block_statement,
			seq($.declaration_statement, ";"),
			$.while_statement,
			$.do_while_statement,
			$.for_statement,
			$.if_statement,
			$.continue_statement,
			$.break_statement,
			$.return_statement,
			$.halt_statement,
			seq($.expression_statement, ";")
		),
		
		block_statement: $ => seq(
			"{",
			repeat($.statement),
			"}"
		),
		
		simple_statement: $ => choice(
			$.declaration_statement,
			$.expression
		),
		
		declaration_statement: $ => seq(
			field("name", $.identifier),
			":",
			field("type", $.type),
			"=",
			field("value", $.expression)
		),
		
		while_statement: $ => seq(
			"while",
			"(",
			field("test", optional($.expression)),
			")",
			field("body", $.statement)
		),
		
		do_while_statement: $ => seq(
			"do",
			field("body", $.statement),
			"while",
			"(",
			field("test", optional($.expression)),
			")",
			";"
		),
		
		for_statement: $ => seq(
			"for",
			"(",
			field("init", optional($.simple_statement)),
			";",
			field("check", optional($.expression)),
			";",
			field("inc", optional($.expression)),
			")",
			field("body", $.statement)
		),
		
		if_statement: $ => prec.left(seq(
			"if",
			"(",
			field("check", $.expression),
			")",
			field("body", $.statement),
			optional(seq(
				"else",
				field("alternate", $.statement)
			))
		)),
		
		continue_statement: $ => seq(
			"continue",
			field("value", optional($.expression)),
			";"
		),
		
		break_statement: $ => seq(
			"break",
			field("value", optional($.expression)),
			";"
		),
		
		return_statement: $ => seq(
			"return",
			field("value", optional($.expression)),
			";"
		),
		
		halt_statement: $ => seq(
			"halt",
			";"
		),
		
		expression_statement: $ => $.expression,
		
		expression: $ => choice(
			$.integer,
			$.boolean,
			$.string,
			$.binary_expression,
			$.call_expression,
			$.array_expression,
			$.parenthesized_expression,
			$.identifier,
		),
		
		parenthesized_expression: $ => seq("(", $.expression, ")"),
		
		binary_expression: $ => choice(...[
			["=", 0],
			["==", 1],
			["<", 2],
			[">", 2],
			["<=", 2],
			[">=", 2],
			["+", 3],
			["-", 3],
			["*", 4],
			["/", 4],
			["%", 4]
		].map(([op, pr]) => {
			return prec.left(pr, seq(
				field("left", $.expression),
				field("op", op),
				field("right", $.expression)
			));
		})),
		
		call_expression: $ => seq(
			field("function", $.expression),
			"(",
			field("arguments", optional($.arguments)),
			")"
		),
		
		array_expression: $ => seq(
			field("array", $.expression),
			"[",
			field("index", $.expression),
			"]"
		),
		
		arguments: $ => sepBy1(",", $.expression),
		
		_call_signature: $ => seq(
			field("name", $.identifier),
			"(",
			field("parameters", optional($.parameters)),
			")",
			field("return_type", optional(seq("->", $.type)))
		),
		
		parameters: $ => sepBy1(",", $.parameter),
		
		parameter: $ => seq(
			field("name", $.identifier),
			":",
			field("type", $.type)
		),
		
		type: $ => seq(
			$.identifier,
			repeat(seq("[", "]"))
		),
		
		identifier: $ => /[a-zA-Z_][a-zA-Z0-9_]*/,
		
		integer: $ => /0|[1-9][0-9]*/,
		
		boolean: $ => choice("true", "false"),
		
		string: $ => seq(
			"\"",
			repeat(choice(
				token.immediate(/[^"\\\n\r]+/),
				$.escape_sequence
			)),
			"\""
		),
		
		escape_sequence: $ => token.immediate(seq(
			"\\",
			choice(
				"\\",
				"\""
			)
		)),
		
		line_comment: $ => /\/\/[^\n\r]*/,
		block_comment: $ => token(seq(
			"/*",
			repeat(choice(
				/[^*]/,
				/\*[^/]/
			)),
			"*/"
		))
	}
});

function sepBy(sep, rule) {
	return optional(sepBy1(sep, rule));
}

function sepBy1(sep, rule) {
	return seq(rule, repeat(seq(sep, rule)));
}
